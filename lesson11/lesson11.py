# Реализация базовой аутентификации

# Шаг 1. Импорт зависимостей. Импортируем необходимые компоненты, включая FastAPI, Depends, status, HTTPException
# и классы для работы с базовой аутентификацией — HTTPBasic и HTTPBasicCredentials.

from fastapi import FastAPI, Depends, status, HTTPException
from pydantic import BaseModel
from fastapi.security import HTTPBasic, HTTPBasicCredentials

# Шаг 2. Создайте приложение Fastapi и экземпляр HTTPBasic

app = FastAPI()
security = HTTPBasic() # будем использовать для извлечения учетных данных из запросов

# Шаг 3. Создайте модель пользователя

class User(BaseModel):
    username : str
    password : str

# имитация БД с информацией о пользователях
USER_DATA = [
    User(**{"username" : "Daniil111", "password" : "123123"}),
    User(**{"username" : "Mark23", "password" : "qwerty"})
]

# Шаг 4. Определите функцию аутентификациии.
# Функция authenticate_user получает учетные данные из запроса через механизм зависимостей FastAPI.
# Если пользователь не найден или введенный пароль не совпадает с сохраненным, выбрасывается исключение с кодом 401 (Unauthorized).

def authenticate_user(credentials: HTTPBasicCredentials = Depends(security)):
    user = get_user_from_db(credentials.username)
    if user is None or user.password != credentials.password:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    return user

# Шаг 5. Задайте логику получения информации о пользователе
# Функция get_user_from_db ищет пользователя по имени в нашей симулированной базе данных.
# Если пользователь найден, функция возвращает его объект; если нет — возвращает None.

def get_user_from_db(username : str) -> User | None :
    for user in USER_DATA:
        if user.username == username:
            return user
    return None

# Шаг 6: Защитите конечные точки с помощью аутентификации
@app.get("/protected_resource/")
def get_protected_resource(user : User = Depends(authenticate_user)):
    return {"message" : "You have access to the protected resource!", "user_info" : user}

# В данном шаге мы защищаем конечную точку /protected_resource/.
# При каждом запросе к этому ресурсу FastAPI сначала выполнит функцию authenticate_user для проверки учетных данных,
# используя механизм зависимости через Depends(authenticate_user).
# Если аутентификация пройдена успешно, пользователь получает доступ к защищенному ресурсу.



# Разберем Depends

# Класс Depends говорит обработчику маршрута, что перед выполнением основного кода маршрута нужно сначала обработать зависимость.
# В него передается объект, который можно вызвать (обычно это функция, но может быть и класс с методом __call__).
# Например:

def my_dependency():
    return "Зависимость выполнена"

@app.get("/")
def get_depends(data = Depends(my_dependency)):
    return {"message" : data}

# В этом примере my_dependency выполняется автоматически перед выполнением get_depends, а ее результат передается в data


# В нашем коде мы используем Depends(authenticate_user). FastAPI перед выполнением маршрута /protected_resource/
# вызывает функцию authenticate_user, но эта функция сама имеет зависимость — security, являющийся экземпляром HTTPBasic().
# Этот класс проверяет заголовок Authorization, сверяет схему аутентификации (Basic) и учетные данные.
# Если они отсутствуют или неверны — выдается ошибка.
# Если всё корректно, то логин и пароль передаются в authenticate_user, который уже проверяет пользователя в нашей базе.

"""
Соображения безопасности
Базовая аутентификация — это простой и удобный способ реализации аутентификации, но у нее есть серьезные ограничения
с точки зрения безопасности. Основная проблема заключается в том, что учетные данные (имя пользователя и пароль) передаются в
запросах в виде обычного текста, что делает их уязвимыми для перехвата. Особенно это опасно при использовании незащищенных
соединений (например, без HTTPS).

Чтобы повысить безопасность, следует рассмотреть более защищенные способы аутентификации. Одним из таких является аутентификация
на основе JWT (JSON Web Token), которая позволяет безопасно передавать информацию о пользователе в виде токенов, которые могут
быть проверены на сервере. Еще один популярный вариант — интеграция с внешними поставщиками аутентификации, такими как OAuth,
который обеспечивает более сложные механизмы безопасности, например, аутентификацию через Google или Facebook*.

В этом уроке мы рассмотрели, как реализовать базовую аутентификацию в FastAPI. Мы изучили, как работает базовая аутентификация,
и пошагово внедрили ее в приложение для защиты определенной конечной точки. Однако, учитывая ограничения этого метода,
не забывайте тщательно подходить к вопросам безопасности в реальных приложениях. В следующем уроке мы рассмотрим аутентификацию
на основе JWT — более безопасную альтернативу базовой аутентификации, которая хорошо подходит для современных веб-приложений.
"""







